import { property as m, queryAssignedNodes as g } from "lit/decorators.js";
import { MutationController as x } from "@lit-labs/observers/mutation-controller.js";
var b = Object.defineProperty, p = (d, n, i, u) => {
  for (var t = void 0, r = d.length - 1, o; r >= 0; r--)
    (o = d[r]) && (t = o(n, i, t) || t);
  return t && b(n, i, t), t;
};
const f = Symbol("assignedNodes");
function N(d, n, i = []) {
  var u, t;
  const r = (c) => (e) => c.matches(e);
  class o extends (t = d, u = f, t) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...e) {
      super(...e), this.slotHasContent = !1, new x(this, {
        config: {
          characterData: !0,
          subtree: !0
        },
        callback: (l) => {
          for (const s of l)
            if (s.type === "characterData") {
              this.manageTextObservedSlot();
              return;
            }
        }
      });
    }
    /**
     * @internal
     */
    manageTextObservedSlot() {
      if (!this[f])
        return;
      const e = [...this[f]].filter(
        (l) => {
          const s = l;
          return s.tagName ? !i.some(r(s)) : s.textContent ? s.textContent.trim() : !1;
        }
      );
      this.slotHasContent = e.length > 0;
    }
    update(e) {
      if (!this.hasUpdated) {
        const { childNodes: l } = this, s = [...l].filter((h) => {
          const a = h;
          return a.tagName ? i.some(
            r(a)
          ) ? !1 : (
            // This pass happens at element upgrade and before slot rendering.
            // Confirm it would exisit in a targeted slot if there was one supplied.
            n ? a.getAttribute("slot") === n : !a.hasAttribute("slot")
          ) : a.textContent ? a.textContent.trim() : !1;
        });
        this.slotHasContent = s.length > 0;
      }
      super.update(e);
    }
    firstUpdated(e) {
      super.firstUpdated(e), this.updateComplete.then(() => {
        this.manageTextObservedSlot();
      });
    }
  }
  return p([
    m({ type: Boolean, attribute: !1 })
  ], o.prototype, "slotHasContent"), p([
    g({
      slot: n,
      flatten: !0
    })
  ], o.prototype, u), o;
}
export {
  N as ObserveSlotText
};
//# sourceMappingURL=observe-slot-text.js.map
